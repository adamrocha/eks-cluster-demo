# Kubernetes Deployment Guide

Deploy hello-world app to EKS using manifests in `manifests/`.

## Prerequisites

AWS CLI, kubectl (v1.28+), EKS cluster via Terraform, kubeconfig updated, Docker image in ECR

## Configuration

**Image:** `802645170184.dkr.ecr.us-east-1.amazonaws.com/hello-world-demo:1.0.0` (nginx:alpine)  
**Security:** Non-root (UID 10001), read-only root FS, dropped capabilities, no privilege escalation  
**Ports:** HTTP 8080→80, HTTPS 8443→443 (self-signed TLS)  
**Resources:** CPU 50m-100m, Memory 32Mi-64Mi  
**Replicas:** 3 (rolling update)  
**Health:** Liveness/readiness on `/` port 8080

## Quick Start

### Using Makefile (Recommended)

```bash
# Validate manifests before deploying
make k8s-validate

# Deploy all manifests
make k8s-apply

# Check deployment status
make k8s-status

# View logs
make k8s-logs

# Open shell in running container
make k8s-shell

# Restart deployment
make k8s-restart

# Delete all resources
make k8s-delete
```

### Using kubectl Directly

```bash
# Apply manifests in order
kubectl apply -f manifests/hello-world-ns.yaml
```bash
# Validate & deploy
make k8s-validate
make k8s-apply

# Check status & get LB URL
make k8s-status

# View logs, shell, restart
make k8s-logs
make k8s-shell
make k8s-restart

# Delete
make k8s-delete
```

**Kustomize:** `make k8s-kustomize-{validate|apply|delete|diff}e image is built via Terraform. To deploy a new version:

```bash
# Update image tag in terraform/variables.tf
# Then rebuild and push
make tf-apply

# Update manifest
vi manifests/hello-world-deployment.yaml
# Change image tag to match new version

# Apply update
kubectl apply -f manifests/hello-world-deployment.yaml

# Or use kubectl set image
kubUpdates & Rollback

**Update image:**
```bash
kubectl set image deployment/hello-world -n hello-world-ns \
  hello-world=802645170184.dkr.ecr.us-east-1.amazonaws.com/hello-world-demo:1.3.3
```

**Rollback:**

```bash
make k8s-undo
# Or: kubectl rollout undo deployment/hello-world -n hello-world-ns [--to-revision=2]

Certificates are generated at container startup by `/usr/local/bin/entrypoint.sh`:

```bash
# Check if certificates exist
kubectl exec -n hello-world-ns <pod-name> -- ls -la /etc/nginx/ssl/

# View certificate details
kubectl exec -n hello-world-ns <pod-name> -- \
  openssl x509 -in /etc/nginx/ssl/nginx.crt -text -noout | grep -A2 "Subject:"

# Check container logs for cert generation
kubectl logs -n hello-world-ns <pod-name> | grep -i certificate
```

### Performance Issues

```bash
# Check resource usage
kubectl top pods -n hello-world-ns

# Check node resources
kubectl top nodes

# View resource limits
kubectl describe deployment hello-world -n hello-world-ns | grep -A5 Limits
```

## Rollback

### Undo Last Deployment

```bash
# Rollback to previous version
make k8s-undo

# Or directly
kubectl rollout undo deployment/hello-world -n hello-world-ns
```

### Rollback to Specific Revision

```bash
# View rollout history
kubectl rollout history deployment/hello-world -n hello-world-ns

# Rollback to specific revision
kubectl rollout undo deployment/hello-world -n hello-world-ns --to-revision=2
```

## Best Practices

1. **Always validate before applying** - Use `make k8s-validate-server`
2. **Use image digests in production** - Pin to specific SHA256 digest
3. **Monitor rollout status** - Watch for errors during deployment
4. **Keep resource limits** - Prevent runaway resource usage
5. **Use health checks** - Ensure containers are actually ready
6. **Enable TLS** - Service supports both HTTP (80) and HTTPS (443)
7. **Review security contexts** - Follow least-privilege principles
8. **Version control manifests** - Track all changes in git

## GitOps Integration

For production environments, consider using GitOps tools:

- **ArgoCD**: Automated sync from git to cluster
- **Flux**: GitOps toolkit for Kubernetes
- **Kustomize**: Environment-specific overlays

## Next Steps

1. ✅ Deploy basic application (this guide)
2. Consider adding:
   - ConfigMaps for configuration
   - Secrets for sensitive data
   - Ingress for HTTP routing
   - HorizontalPodAutoscaler for auto-scaling
   - PodDisruptionBudget for availability
   - NetworkPolicy for traffic control
   - ServiceMonitor for Prometheus metrics

## References

- [Kubernetes Documentation](https://kubernetes.io/docs/)
- [kubectl Cheat Sheet](https://kubernetes.io/docs/reference/kubectl/cheatsheet/)
- [Kustomize](https://kustomize.io/)
- [AWS Load Balancer Controller](https://kubernetes-sigs.github.io/aws-load-balancer-controller/)

## Troubleshooting

**CrashLoopBackOff:** `kubectl describe pod <pod> -n hello-world-ns` → `kubectl logs <pod> -n hello-world-ns [--previous]`  
**Image pull errors:** Check ECR image exists, verify node IAM permissions  
**LB not provisioning:** `kubectl describe svc hello-world-service -n hello-world-ns`  
**Cert issues:** Certs auto-generated by entrypoint.sh - check with `kubectl exec -n hello-world-ns <pod> -- ls -la /etc/nginx/ssl/`  
**Performance:** `kubectl top pods -n hello-world-ns`

## Key Reminders

- Validate before applying (`make k8s-validate-server`)
- Use image digests in production (pin SHA256)
- Monitor rollout status, keep resource limits
- Use health checks, enable TLS
- Review security contexts (least-privilege)
- Version control manifests
